{"version":3,"names":["rangeIosCss","rangeMdCss","Range","constructor","hostRef","this","didLoad","noUpdate","hasFocus","inheritedAttributes","contentEl","initialContentScrollY","ratioA","ratioB","debounce","name","dualKnobs","min","max","pin","pinFormatter","value","Math","round","snaps","step","ticks","disabled","clampBounds","clamp","ensureValueInBounds","lower","upper","setupGesture","async","rangeSlider","gesture","import","createGesture","el","gestureName","gesturePriority","threshold","onStart","ev","onMove","onEnd","enable","handleKeyboard","knob","isIncrease","ionKnobMoveStart","emit","updateValue","ionKnobMoveEnd","onBlur","ionBlur","emitStyle","onFocus","ionFocus","debounceChanged","ionChange","debounceEvent","minChanged","updateRatio","maxChanged","activeBarStartChanged","activeBarStart","undefined","printIonWarning","disabledChanged","valueChanged","componentWillLoad","rangeId","hasAttribute","getAttribute","rangeIds","inheritAriaAttributes","componentDidLoad","connectedCallback","findClosestIonContent","disconnectedCallback","destroy","getValue","_a","ionStyle","interactive","detail","disableContentScrollY","rect","getBoundingClientRect","currentX","ratio","left","width","isRTL","pressedKnob","abs","setFocus","update","resetContentScrollY","valueToRatio","ratioToValue","valA","valB","ratioLower","ratioUpper","shadowRoot","knobEl","querySelector","focus","render","labelText","getAriaLabel","mode","getIonMode","barStart","barEnd","rtl","start","end","tickStyle","tick","barStyle","ratioMin","ratioMax","active","push","renderHiddenInput","JSON","stringify","h","Host","onFocusin","onFocusout","id","class","createColorClasses","color","hostContext","ref","rangeEl","map","style","role","part","renderKnob","pressed","knobStyle","onKeyDown","key","preventDefault","stopPropagation","tabindex"],"sources":["./node_modules/@ionic/core/dist/collection/components/range/range.ios.css?tag=ion-range&mode=ios&encapsulation=shadow","./node_modules/@ionic/core/dist/collection/components/range/range.md.css?tag=ion-range&mode=md&encapsulation=shadow","./node_modules/@ionic/core/dist/collection/components/range/range.js"],"sourcesContent":[":host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  left: 0;\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  margin-left: calc(0px - var(--knob-handle-size) / 2);\n  position: absolute;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-knob-handle {\n    margin-left: unset;\n    -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n    margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  }\n}\n[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  left: 0;\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  left: calc(50% - var(--knob-size) / 2);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob {\n  left: unset;\n  right: unset;\n  right: calc(50% - var(--knob-size) / 2);\n}\n\n[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: #ffffff;\n  --knob-box-shadow: 0 3px 1px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.13), 0 0 0 1px rgba(0, 0, 0, 0.02);\n  --knob-size: 28px;\n  --bar-height: 2px;\n  --bar-background: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1);\n  --bar-background-active: var(--ion-color-primary, #3880ff);\n  --bar-border-radius: 0;\n  --height: 42px;\n  padding-left: 16px;\n  padding-right: 16px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  :host {\n    padding-left: unset;\n    padding-right: unset;\n    -webkit-padding-start: 16px;\n    padding-inline-start: 16px;\n    -webkit-padding-end: 16px;\n    padding-inline-end: 16px;\n  }\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-tick-active {\n  background: var(--ion-color-base);\n}\n\n::slotted([slot=start]) {\n  margin-left: 0;\n  margin-right: 16px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  ::slotted([slot=start]) {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: 0;\n    margin-inline-start: 0;\n    -webkit-margin-end: 16px;\n    margin-inline-end: 16px;\n  }\n}\n\n::slotted([slot=end]) {\n  margin-left: 16px;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  ::slotted([slot=end]) {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: 16px;\n    margin-inline-start: 16px;\n    -webkit-margin-end: 0;\n    margin-inline-end: 0;\n  }\n}\n\n:host(.range-has-pin) {\n  padding-top: 20px;\n}\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n\n.range-tick {\n  margin-left: -1px;\n  border-radius: 0;\n  position: absolute;\n  top: 18px;\n  width: 2px;\n  height: 8px;\n  background: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1);\n  pointer-events: none;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-tick {\n    margin-left: unset;\n    -webkit-margin-start: -1px;\n    margin-inline-start: -1px;\n  }\n}\n\n.range-tick-active {\n  background: var(--bar-background-active);\n}\n\n.range-pin {\n  transform: translate3d(0,  28px,  0) scale(0.01);\n  padding-left: 8px;\n  padding-right: 8px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  display: inline-block;\n  position: relative;\n  top: -20px;\n  min-width: 28px;\n  transition: transform 120ms ease;\n  background: transparent;\n  color: var(--ion-text-color, #000);\n  font-size: 12px;\n  text-align: center;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-pin {\n    padding-left: unset;\n    padding-right: unset;\n    -webkit-padding-start: 8px;\n    padding-inline-start: 8px;\n    -webkit-padding-end: 8px;\n    padding-inline-end: 8px;\n  }\n}\n\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0,  0,  0) scale(1);\n}\n\n:host(.range-disabled) {\n  opacity: 0.5;\n}",":host {\n  /**\n   * @prop --bar-background: Background of the range bar\n   * @prop --bar-background-active: Background of the active range bar\n   * @prop --bar-height: Height of the range bar\n   * @prop --bar-border-radius: Border radius of the range bar\n   * @prop --height: Height of the range\n   * @prop --knob-background: Background of the range knob\n   * @prop --knob-border-radius: Border radius of the range knob\n   * @prop --knob-box-shadow: Box shadow of the range knob\n   * @prop --knob-size: Size of the range knob\n   * @prop --pin-background: Background of the range pin (only available in MD mode)\n   * @prop --pin-color: Color of the range pin (only available in MD mode)\n   */\n  --knob-handle-size: calc(var(--knob-size) * 2);\n  display: flex;\n  position: relative;\n  flex: 3;\n  align-items: center;\n  font-family: var(--ion-font-family, inherit);\n  user-select: none;\n  z-index: 2;\n}\n\n:host(.range-disabled) {\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  flex: initial;\n}\n\n::slotted(ion-icon[slot]) {\n  font-size: 24px;\n}\n\n.range-slider {\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: var(--height);\n  contain: size layout style;\n  cursor: grab;\n  touch-action: pan-y;\n}\n\n:host(.range-pressed) .range-slider {\n  cursor: grabbing;\n}\n\n.range-pin {\n  position: absolute;\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n  text-align: center;\n  box-sizing: border-box;\n}\n\n.range-knob-handle {\n  left: 0;\n  top: calc((var(--height) - var(--knob-handle-size)) / 2);\n  margin-left: calc(0px - var(--knob-handle-size) / 2);\n  position: absolute;\n  width: var(--knob-handle-size);\n  height: var(--knob-handle-size);\n  text-align: center;\n}\n[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-knob-handle {\n    margin-left: unset;\n    -webkit-margin-start: calc(0px - var(--knob-handle-size) / 2);\n    margin-inline-start: calc(0px - var(--knob-handle-size) / 2);\n  }\n}\n[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob-handle:active, .range-knob-handle:focus {\n  outline: none;\n}\n\n.range-bar {\n  border-radius: var(--bar-border-radius);\n  left: 0;\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  position: absolute;\n  width: 100%;\n  height: var(--bar-height);\n  background: var(--bar-background);\n  pointer-events: none;\n}\n[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob {\n  border-radius: var(--knob-border-radius);\n  left: calc(50% - var(--knob-size) / 2);\n  top: calc(50% - var(--knob-size) / 2);\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  background: var(--knob-background);\n  box-shadow: var(--knob-box-shadow);\n  z-index: 2;\n  pointer-events: none;\n}\n[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob {\n  left: unset;\n  right: unset;\n  right: calc(50% - var(--knob-size) / 2);\n}\n\n[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n:host(.range-pressed) .range-bar-active {\n  will-change: left, right;\n}\n\n:host(.in-item) {\n  width: 100%;\n}\n\n:host(.in-item) ::slotted(ion-label) {\n  align-self: center;\n}\n\n:host {\n  --knob-border-radius: 50%;\n  --knob-background: var(--bar-background-active);\n  --knob-box-shadow: none;\n  --knob-size: 18px;\n  --bar-height: 2px;\n  --bar-background: rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.26);\n  --bar-background-active: var(--ion-color-primary, #3880ff);\n  --bar-border-radius: 0;\n  --height: 42px;\n  --pin-background: var(--ion-color-primary, #3880ff);\n  --pin-color: var(--ion-color-primary-contrast, #fff);\n  padding-left: 14px;\n  padding-right: 14px;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  font-size: 12px;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  :host {\n    padding-left: unset;\n    padding-right: unset;\n    -webkit-padding-start: 14px;\n    padding-inline-start: 14px;\n    -webkit-padding-end: 14px;\n    padding-inline-end: 14px;\n  }\n}\n\n:host(.ion-color) .range-bar {\n  background: rgba(var(--ion-color-base-rgb), 0.26);\n}\n\n:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-knob,\n:host(.ion-color) .range-knob::before,\n:host(.ion-color) .range-pin,\n:host(.ion-color) .range-pin::before,\n:host(.ion-color) .range-tick {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n::slotted([slot=start]) {\n  margin-left: 0;\n  margin-right: 14px;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  ::slotted([slot=start]) {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: 0;\n    margin-inline-start: 0;\n    -webkit-margin-end: 14px;\n    margin-inline-end: 14px;\n  }\n}\n\n::slotted([slot=end]) {\n  margin-left: 14px;\n  margin-right: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  ::slotted([slot=end]) {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: 14px;\n    margin-inline-start: 14px;\n    -webkit-margin-end: 0;\n    margin-inline-end: 0;\n  }\n}\n\n:host(.range-has-pin) {\n  padding-top: 28px;\n}\n.range-bar-active {\n  bottom: 0;\n  width: auto;\n  background: var(--bar-background-active);\n}\n\n.range-knob {\n  transform: scale(0.67);\n  transition-duration: 120ms;\n  transition-property: transform, background-color, border;\n  transition-timing-function: ease;\n  z-index: 2;\n}\n.range-knob::before {\n  border-radius: 50%;\n  left: 0;\n  position: absolute;\n  width: var(--knob-size);\n  height: var(--knob-size);\n  transform: scale(1);\n  transition: 0.267s cubic-bezier(0, 0, 0.58, 1);\n  background: var(--knob-background);\n  content: \"\";\n  opacity: 0.13;\n  pointer-events: none;\n}\n[dir=rtl] .range-knob::before, :host-context([dir=rtl]) .range-knob::before {\n  left: unset;\n  right: unset;\n  right: 0;\n}\n\n.range-tick {\n  position: absolute;\n  top: calc((var(--height) - var(--bar-height)) / 2);\n  width: var(--bar-height);\n  height: var(--bar-height);\n  background: var(--bar-background-active);\n  z-index: 1;\n  pointer-events: none;\n}\n\n.range-tick-active {\n  background: transparent;\n}\n\n.range-pin {\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  border-radius: 50%;\n  transform: translate3d(0,  0,  0) scale(0.01);\n  display: inline-block;\n  position: relative;\n  min-width: 28px;\n  height: 28px;\n  transition: transform 120ms ease, background 120ms ease;\n  background: var(--pin-background);\n  color: var(--pin-color);\n  text-align: center;\n}\n.range-pin::before {\n  left: 50%;\n  top: 3px;\n  margin-left: -13px;\n  /* stylelint-disable-next-line property-disallowed-list */\n  border-radius: 50% 50% 50% 0;\n  position: absolute;\n  width: 26px;\n  height: 26px;\n  transform: rotate(-45deg);\n  transition: background 120ms ease;\n  background: var(--pin-background);\n  content: \"\";\n  z-index: -1;\n}\n[dir=rtl] .range-pin::before, :host-context([dir=rtl]) .range-pin::before {\n  left: unset;\n  right: unset;\n  right: 50%;\n}\n\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .range-pin::before {\n    margin-left: unset;\n    -webkit-margin-start: -13px;\n    margin-inline-start: -13px;\n  }\n}\n[dir=rtl] .range-pin::before, :host-context([dir=rtl]) .range-pin::before {\n  /* stylelint-disable-next-line property-disallowed-list */\n  left: unset;\n}\n\n.range-knob-pressed .range-pin,\n.range-knob-handle.ion-focused .range-pin {\n  transform: translate3d(0,  -24px,  0) scale(1);\n}\n\n@media (any-hover: hover) {\n  .range-knob-handle:hover .range-knob:before {\n    transform: scale(2);\n    opacity: 0.13;\n  }\n}\n.range-knob-handle.ion-activated .range-knob:before, .range-knob-handle.ion-focused .range-knob:before, .range-knob-handle.range-knob-pressed .range-knob:before {\n  transform: scale(2);\n}\n.range-knob-handle.ion-focused .range-knob::before {\n  opacity: 0.13;\n}\n.range-knob-handle.ion-activated .range-knob::before, .range-knob-handle.range-knob-pressed .range-knob::before {\n  opacity: 0.25;\n}\n\n:host(:not(.range-has-pin)) .range-knob-pressed .range-knob,\n:host(:not(.range-has-pin)) .range-knob-handle.ion-focused .range-knob {\n  transform: scale(1);\n}\n\n:host(.range-disabled) .range-bar-active,\n:host(.range-disabled) .range-bar,\n:host(.range-disabled) .range-tick {\n  background-color: var(--ion-color-step-250, #bfbfbf);\n}\n\n:host(.range-disabled) .range-knob {\n  transform: scale(0.55);\n  outline: 5px solid #fff;\n  background-color: var(--ion-color-step-250, #bfbfbf);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from '@stencil/core';\nimport { getIonMode } from '../../global/ionic-global';\nimport { findClosestIonContent, disableContentScrollY, resetContentScrollY } from '../../utils/content';\nimport { inheritAriaAttributes, clamp, debounceEvent, getAriaLabel, renderHiddenInput } from '../../utils/helpers';\nimport { printIonWarning } from '../../utils/logging';\nimport { isRTL } from '../../utils/rtl';\nimport { createColorClasses, hostContext } from '../../utils/theme';\n// TODO(FW-2832): types\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @slot start - Content is placed to the left of the range slider in LTR, and to the right in RTL.\n * @slot end - Content is placed to the right of the range slider in LTR, and to the left in RTL.\n *\n * @part tick - An inactive tick mark.\n * @part tick-active - An active tick mark.\n * @part pin - The counter that appears above a knob.\n * @part knob - The handle that is used to drag the range.\n * @part bar - The inactive part of the bar.\n * @part bar-active - The active part of the bar.\n */\nexport class Range {\n  constructor() {\n    this.didLoad = false;\n    this.noUpdate = false;\n    this.hasFocus = false;\n    this.inheritedAttributes = {};\n    this.contentEl = null;\n    this.initialContentScrollY = true;\n    this.ratioA = 0;\n    this.ratioB = 0;\n    /**\n     * How long, in milliseconds, to wait to trigger the\n     * `ionChange` event after each change in the range value.\n     * This also impacts form bindings such as `ngModel` or `v-model`.\n     */\n    this.debounce = 0;\n    // TODO: In Ionic Framework v6 this should initialize to this.rangeId like the other form components do.\n    /**\n     * The name of the control, which is submitted with the form data.\n     */\n    this.name = '';\n    /**\n     * Show two knobs.\n     */\n    this.dualKnobs = false;\n    /**\n     * Minimum integer value of the range.\n     */\n    this.min = 0;\n    /**\n     * Maximum integer value of the range.\n     */\n    this.max = 100;\n    /**\n     * If `true`, a pin with integer value is shown when the knob\n     * is pressed.\n     */\n    this.pin = false;\n    /**\n     * A callback used to format the pin text.\n     * By default the pin text is set to `Math.round(value)`.\n     */\n    this.pinFormatter = (value) => Math.round(value);\n    /**\n     * If `true`, the knob snaps to tick marks evenly spaced based\n     * on the step property value.\n     */\n    this.snaps = false;\n    /**\n     * Specifies the value granularity.\n     */\n    this.step = 1;\n    /**\n     * If `true`, tick marks are displayed based on the step value.\n     * Only applies when `snaps` is `true`.\n     */\n    this.ticks = true;\n    /**\n     * If `true`, the user cannot interact with the range.\n     */\n    this.disabled = false;\n    /**\n     * the value of the range.\n     */\n    this.value = 0;\n    this.clampBounds = (value) => {\n      return clamp(this.min, value, this.max);\n    };\n    this.ensureValueInBounds = (value) => {\n      if (this.dualKnobs) {\n        return {\n          lower: this.clampBounds(value.lower),\n          upper: this.clampBounds(value.upper),\n        };\n      }\n      else {\n        return this.clampBounds(value);\n      }\n    };\n    this.setupGesture = async () => {\n      const rangeSlider = this.rangeSlider;\n      if (rangeSlider) {\n        this.gesture = (await import('../../utils/gesture')).createGesture({\n          el: rangeSlider,\n          gestureName: 'range',\n          gesturePriority: 100,\n          threshold: 0,\n          onStart: (ev) => this.onStart(ev),\n          onMove: (ev) => this.onMove(ev),\n          onEnd: (ev) => this.onEnd(ev),\n        });\n        this.gesture.enable(!this.disabled);\n      }\n    };\n    this.handleKeyboard = (knob, isIncrease) => {\n      const { ensureValueInBounds } = this;\n      let step = this.step;\n      step = step > 0 ? step : 1;\n      step = step / (this.max - this.min);\n      if (!isIncrease) {\n        step *= -1;\n      }\n      if (knob === 'A') {\n        this.ratioA = clamp(0, this.ratioA + step, 1);\n      }\n      else {\n        this.ratioB = clamp(0, this.ratioB + step, 1);\n      }\n      this.ionKnobMoveStart.emit({ value: ensureValueInBounds(this.value) });\n      this.updateValue();\n      this.ionKnobMoveEnd.emit({ value: ensureValueInBounds(this.value) });\n    };\n    this.onBlur = () => {\n      if (this.hasFocus) {\n        this.hasFocus = false;\n        this.ionBlur.emit();\n        this.emitStyle();\n      }\n    };\n    this.onFocus = () => {\n      if (!this.hasFocus) {\n        this.hasFocus = true;\n        this.ionFocus.emit();\n        this.emitStyle();\n      }\n    };\n  }\n  debounceChanged() {\n    this.ionChange = debounceEvent(this.ionChange, this.debounce);\n  }\n  minChanged() {\n    if (!this.noUpdate) {\n      this.updateRatio();\n    }\n  }\n  maxChanged() {\n    if (!this.noUpdate) {\n      this.updateRatio();\n    }\n  }\n  activeBarStartChanged() {\n    const { activeBarStart } = this;\n    if (activeBarStart !== undefined) {\n      if (activeBarStart > this.max) {\n        printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is greater than the max (${this.max}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n        this.activeBarStart = this.max;\n      }\n      else if (activeBarStart < this.min) {\n        printIonWarning(`Range: The value of activeBarStart (${activeBarStart}) is less than the min (${this.min}). Valid values are greater than or equal to the min value and less than or equal to the max value.`, this.el);\n        this.activeBarStart = this.min;\n      }\n    }\n  }\n  disabledChanged() {\n    if (this.gesture) {\n      this.gesture.enable(!this.disabled);\n    }\n    this.emitStyle();\n  }\n  valueChanged(value) {\n    if (!this.noUpdate) {\n      this.updateRatio();\n    }\n    value = this.ensureValueInBounds(value);\n    this.ionChange.emit({ value });\n  }\n  componentWillLoad() {\n    /**\n     * If user has custom ID set then we should\n     * not assign the default incrementing ID.\n     */\n    this.rangeId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : `ion-r-${rangeIds++}`;\n    this.inheritedAttributes = inheritAriaAttributes(this.el);\n  }\n  componentDidLoad() {\n    this.setupGesture();\n    this.didLoad = true;\n  }\n  connectedCallback() {\n    this.updateRatio();\n    this.debounceChanged();\n    this.disabledChanged();\n    this.activeBarStartChanged();\n    /**\n     * If we have not yet rendered\n     * ion-range, then rangeSlider is not defined.\n     * But if we are moving ion-range via appendChild,\n     * then rangeSlider will be defined.\n     */\n    if (this.didLoad) {\n      this.setupGesture();\n    }\n    this.contentEl = findClosestIonContent(this.el);\n  }\n  disconnectedCallback() {\n    if (this.gesture) {\n      this.gesture.destroy();\n      this.gesture = undefined;\n    }\n  }\n  getValue() {\n    var _a;\n    const value = (_a = this.value) !== null && _a !== void 0 ? _a : 0;\n    if (this.dualKnobs) {\n      if (typeof value === 'object') {\n        return value;\n      }\n      return {\n        lower: 0,\n        upper: value,\n      };\n    }\n    else {\n      if (typeof value === 'object') {\n        return value.upper;\n      }\n      return value;\n    }\n  }\n  emitStyle() {\n    this.ionStyle.emit({\n      interactive: true,\n      'interactive-disabled': this.disabled,\n    });\n  }\n  onStart(detail) {\n    const { contentEl } = this;\n    if (contentEl) {\n      this.initialContentScrollY = disableContentScrollY(contentEl);\n    }\n    const rect = (this.rect = this.rangeSlider.getBoundingClientRect());\n    const currentX = detail.currentX;\n    // figure out which knob they started closer to\n    let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n    if (isRTL(this.el)) {\n      ratio = 1 - ratio;\n    }\n    this.pressedKnob = !this.dualKnobs || Math.abs(this.ratioA - ratio) < Math.abs(this.ratioB - ratio) ? 'A' : 'B';\n    this.setFocus(this.pressedKnob);\n    // update the active knob's position\n    this.update(currentX);\n    this.ionKnobMoveStart.emit({ value: this.ensureValueInBounds(this.value) });\n  }\n  onMove(detail) {\n    this.update(detail.currentX);\n  }\n  onEnd(detail) {\n    const { contentEl, initialContentScrollY } = this;\n    if (contentEl) {\n      resetContentScrollY(contentEl, initialContentScrollY);\n    }\n    this.update(detail.currentX);\n    this.pressedKnob = undefined;\n    this.ionKnobMoveEnd.emit({ value: this.ensureValueInBounds(this.value) });\n  }\n  update(currentX) {\n    // figure out where the pointer is currently at\n    // update the knob being interacted with\n    const rect = this.rect;\n    let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);\n    if (isRTL(this.el)) {\n      ratio = 1 - ratio;\n    }\n    if (this.snaps) {\n      // snaps the ratio to the current value\n      ratio = valueToRatio(ratioToValue(ratio, this.min, this.max, this.step), this.min, this.max);\n    }\n    // update which knob is pressed\n    if (this.pressedKnob === 'A') {\n      this.ratioA = ratio;\n    }\n    else {\n      this.ratioB = ratio;\n    }\n    // Update input value\n    this.updateValue();\n  }\n  get valA() {\n    return ratioToValue(this.ratioA, this.min, this.max, this.step);\n  }\n  get valB() {\n    return ratioToValue(this.ratioB, this.min, this.max, this.step);\n  }\n  get ratioLower() {\n    if (this.dualKnobs) {\n      return Math.min(this.ratioA, this.ratioB);\n    }\n    const { activeBarStart } = this;\n    if (activeBarStart == null) {\n      return 0;\n    }\n    return valueToRatio(activeBarStart, this.min, this.max);\n  }\n  get ratioUpper() {\n    if (this.dualKnobs) {\n      return Math.max(this.ratioA, this.ratioB);\n    }\n    return this.ratioA;\n  }\n  updateRatio() {\n    const value = this.getValue();\n    const { min, max } = this;\n    if (this.dualKnobs) {\n      this.ratioA = valueToRatio(value.lower, min, max);\n      this.ratioB = valueToRatio(value.upper, min, max);\n    }\n    else {\n      this.ratioA = valueToRatio(value, min, max);\n    }\n  }\n  updateValue() {\n    this.noUpdate = true;\n    const { valA, valB } = this;\n    this.value = !this.dualKnobs\n      ? valA\n      : {\n        lower: Math.min(valA, valB),\n        upper: Math.max(valA, valB),\n      };\n    this.noUpdate = false;\n  }\n  setFocus(knob) {\n    if (this.el.shadowRoot) {\n      const knobEl = this.el.shadowRoot.querySelector(knob === 'A' ? '.range-knob-a' : '.range-knob-b');\n      if (knobEl) {\n        knobEl.focus();\n      }\n    }\n  }\n  render() {\n    var _a;\n    const { min, max, step, el, handleKeyboard, pressedKnob, disabled, pin, ratioLower, ratioUpper, inheritedAttributes, rangeId, pinFormatter, } = this;\n    /**\n     * Look for external label, ion-label, or aria-labelledby.\n     * If none, see if user placed an aria-label on the host\n     * and use that instead.\n     */\n    let { labelText } = getAriaLabel(el, rangeId);\n    if (labelText === undefined || labelText === null) {\n      labelText = inheritedAttributes['aria-label'];\n    }\n    const mode = getIonMode(this);\n    let barStart = `${ratioLower * 100}%`;\n    let barEnd = `${100 - ratioUpper * 100}%`;\n    const rtl = isRTL(this.el);\n    const start = rtl ? 'right' : 'left';\n    const end = rtl ? 'left' : 'right';\n    const tickStyle = (tick) => {\n      return {\n        [start]: tick[start],\n      };\n    };\n    if (this.dualKnobs === false) {\n      /**\n       * When the value is less than the activeBarStart or the min value,\n       * the knob will display at the start of the active bar.\n       */\n      if (this.valA < ((_a = this.activeBarStart) !== null && _a !== void 0 ? _a : this.min)) {\n        /**\n         * Sets the bar positions relative to the upper and lower limits.\n         * Converts the ratio values into percentages, used as offsets for left/right styles.\n         *\n         * The ratioUpper refers to the knob position on the bar.\n         * The ratioLower refers to the end position of the active bar (the value).\n         */\n        barStart = `${ratioUpper * 100}%`;\n        barEnd = `${100 - ratioLower * 100}%`;\n      }\n      else {\n        /**\n         * Otherwise, the knob will display at the end of the active bar.\n         *\n         * The ratioLower refers to the start position of the active bar (the value).\n         * The ratioUpper refers to the knob position on the bar.\n         */\n        barStart = `${ratioLower * 100}%`;\n        barEnd = `${100 - ratioUpper * 100}%`;\n      }\n    }\n    const barStyle = {\n      [start]: barStart,\n      [end]: barEnd,\n    };\n    const ticks = [];\n    if (this.snaps && this.ticks) {\n      for (let value = min; value <= max; value += step) {\n        const ratio = valueToRatio(value, min, max);\n        const ratioMin = Math.min(ratioLower, ratioUpper);\n        const ratioMax = Math.max(ratioLower, ratioUpper);\n        const tick = {\n          ratio,\n          /**\n           * Sets the tick mark as active when the tick is between the min bounds and the knob.\n           * When using activeBarStart, the tick mark will be active between the knob and activeBarStart.\n           */\n          active: ratio >= ratioMin && ratio <= ratioMax,\n        };\n        tick[start] = `${ratio * 100}%`;\n        ticks.push(tick);\n      }\n    }\n    renderHiddenInput(true, el, this.name, JSON.stringify(this.getValue()), disabled);\n    return (h(Host, { onFocusin: this.onFocus, onFocusout: this.onBlur, id: rangeId, class: createColorClasses(this.color, {\n        [mode]: true,\n        'in-item': hostContext('ion-item', el),\n        'range-disabled': disabled,\n        'range-pressed': pressedKnob !== undefined,\n        'range-has-pin': pin,\n      }) }, h(\"slot\", { name: \"start\" }), h(\"div\", { class: \"range-slider\", ref: (rangeEl) => (this.rangeSlider = rangeEl) }, ticks.map((tick) => (h(\"div\", { style: tickStyle(tick), role: \"presentation\", class: {\n        'range-tick': true,\n        'range-tick-active': tick.active,\n      }, part: tick.active ? 'tick-active' : 'tick' }))), h(\"div\", { class: \"range-bar\", role: \"presentation\", part: \"bar\" }), h(\"div\", { class: \"range-bar range-bar-active\", role: \"presentation\", style: barStyle, part: \"bar-active\" }), renderKnob(rtl, {\n      knob: 'A',\n      pressed: pressedKnob === 'A',\n      value: this.valA,\n      ratio: this.ratioA,\n      pin,\n      pinFormatter,\n      disabled,\n      handleKeyboard,\n      min,\n      max,\n      labelText,\n    }), this.dualKnobs &&\n      renderKnob(rtl, {\n        knob: 'B',\n        pressed: pressedKnob === 'B',\n        value: this.valB,\n        ratio: this.ratioB,\n        pin,\n        pinFormatter,\n        disabled,\n        handleKeyboard,\n        min,\n        max,\n        labelText,\n      })), h(\"slot\", { name: \"end\" })));\n  }\n  static get is() { return \"ion-range\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"ios\": [\"range.ios.scss\"],\n      \"md\": [\"range.md.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"ios\": [\"range.ios.css\"],\n      \"md\": [\"range.md.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"color\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"Color\",\n          \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n          \"references\": {\n            \"Color\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n        },\n        \"attribute\": \"color\",\n        \"reflect\": true\n      },\n      \"debounce\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"How long, in milliseconds, to wait to trigger the\\n`ionChange` event after each change in the range value.\\nThis also impacts form bindings such as `ngModel` or `v-model`.\"\n        },\n        \"attribute\": \"debounce\",\n        \"reflect\": false,\n        \"defaultValue\": \"0\"\n      },\n      \"name\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string\",\n          \"resolved\": \"string\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The name of the control, which is submitted with the form data.\"\n        },\n        \"attribute\": \"name\",\n        \"reflect\": false,\n        \"defaultValue\": \"''\"\n      },\n      \"dualKnobs\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Show two knobs.\"\n        },\n        \"attribute\": \"dual-knobs\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"min\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Minimum integer value of the range.\"\n        },\n        \"attribute\": \"min\",\n        \"reflect\": false,\n        \"defaultValue\": \"0\"\n      },\n      \"max\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Maximum integer value of the range.\"\n        },\n        \"attribute\": \"max\",\n        \"reflect\": false,\n        \"defaultValue\": \"100\"\n      },\n      \"pin\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, a pin with integer value is shown when the knob\\nis pressed.\"\n        },\n        \"attribute\": \"pin\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"pinFormatter\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"PinFormatter\",\n          \"resolved\": \"(value: number) => string | number\",\n          \"references\": {\n            \"PinFormatter\": {\n              \"location\": \"import\",\n              \"path\": \"./range-interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A callback used to format the pin text.\\nBy default the pin text is set to `Math.round(value)`.\"\n        },\n        \"defaultValue\": \"(value: number): number => Math.round(value)\"\n      },\n      \"snaps\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the knob snaps to tick marks evenly spaced based\\non the step property value.\"\n        },\n        \"attribute\": \"snaps\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"step\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Specifies the value granularity.\"\n        },\n        \"attribute\": \"step\",\n        \"reflect\": false,\n        \"defaultValue\": \"1\"\n      },\n      \"ticks\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, tick marks are displayed based on the step value.\\nOnly applies when `snaps` is `true`.\"\n        },\n        \"attribute\": \"ticks\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"activeBarStart\": {\n        \"type\": \"number\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The start position of the range active bar. This feature is only available with a single knob (dualKnobs=\\\"false\\\").\\nValid values are greater than or equal to the min value and less than or equal to the max value.\"\n        },\n        \"attribute\": \"active-bar-start\",\n        \"reflect\": false\n      },\n      \"disabled\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the user cannot interact with the range.\"\n        },\n        \"attribute\": \"disabled\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"value\": {\n        \"type\": \"number\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"RangeValue\",\n          \"resolved\": \"number | { lower: number; upper: number; }\",\n          \"references\": {\n            \"RangeValue\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"the value of the range.\"\n        },\n        \"attribute\": \"value\",\n        \"reflect\": false,\n        \"defaultValue\": \"0\"\n      }\n    };\n  }\n  static get states() {\n    return {\n      \"ratioA\": {},\n      \"ratioB\": {},\n      \"pressedKnob\": {}\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionChange\",\n        \"name\": \"ionChange\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the value property has changed.\"\n        },\n        \"complexType\": {\n          \"original\": \"RangeChangeEventDetail\",\n          \"resolved\": \"RangeChangeEventDetail\",\n          \"references\": {\n            \"RangeChangeEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionStyle\",\n        \"name\": \"ionStyle\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"Emitted when the styles change.\"\n        },\n        \"complexType\": {\n          \"original\": \"StyleEventDetail\",\n          \"resolved\": \"StyleEventDetail\",\n          \"references\": {\n            \"StyleEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionFocus\",\n        \"name\": \"ionFocus\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the range has focus.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionBlur\",\n        \"name\": \"ionBlur\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the range loses focus.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"ionKnobMoveStart\",\n        \"name\": \"ionKnobMoveStart\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the user starts moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n        },\n        \"complexType\": {\n          \"original\": \"RangeKnobMoveStartEventDetail\",\n          \"resolved\": \"RangeKnobMoveStartEventDetail\",\n          \"references\": {\n            \"RangeKnobMoveStartEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionKnobMoveEnd\",\n        \"name\": \"ionKnobMoveEnd\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the user finishes moving the range knob, whether through\\nmouse drag, touch gesture, or keyboard interaction.\"\n        },\n        \"complexType\": {\n          \"original\": \"RangeKnobMoveEndEventDetail\",\n          \"resolved\": \"RangeKnobMoveEndEventDetail\",\n          \"references\": {\n            \"RangeKnobMoveEndEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }];\n  }\n  static get elementRef() { return \"el\"; }\n  static get watchers() {\n    return [{\n        \"propName\": \"debounce\",\n        \"methodName\": \"debounceChanged\"\n      }, {\n        \"propName\": \"min\",\n        \"methodName\": \"minChanged\"\n      }, {\n        \"propName\": \"max\",\n        \"methodName\": \"maxChanged\"\n      }, {\n        \"propName\": \"activeBarStart\",\n        \"methodName\": \"activeBarStartChanged\"\n      }, {\n        \"propName\": \"disabled\",\n        \"methodName\": \"disabledChanged\"\n      }, {\n        \"propName\": \"value\",\n        \"methodName\": \"valueChanged\"\n      }];\n  }\n}\nconst renderKnob = (rtl, { knob, value, ratio, min, max, disabled, pressed, pin, handleKeyboard, labelText, pinFormatter }) => {\n  const start = rtl ? 'right' : 'left';\n  const knobStyle = () => {\n    const style = {};\n    style[start] = `${ratio * 100}%`;\n    return style;\n  };\n  return (h(\"div\", { onKeyDown: (ev) => {\n      const key = ev.key;\n      if (key === 'ArrowLeft' || key === 'ArrowDown') {\n        handleKeyboard(knob, false);\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n      else if (key === 'ArrowRight' || key === 'ArrowUp') {\n        handleKeyboard(knob, true);\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }, class: {\n      'range-knob-handle': true,\n      'range-knob-a': knob === 'A',\n      'range-knob-b': knob === 'B',\n      'range-knob-pressed': pressed,\n      'range-knob-min': value === min,\n      'range-knob-max': value === max,\n      'ion-activatable': true,\n      'ion-focusable': true,\n    }, style: knobStyle(), role: \"slider\", tabindex: disabled ? -1 : 0, \"aria-label\": labelText, \"aria-valuemin\": min, \"aria-valuemax\": max, \"aria-disabled\": disabled ? 'true' : null, \"aria-valuenow\": value }, pin && (h(\"div\", { class: \"range-pin\", role: \"presentation\", part: \"pin\" }, pinFormatter(value))), h(\"div\", { class: \"range-knob\", role: \"presentation\", part: \"knob\" })));\n};\nconst ratioToValue = (ratio, min, max, step) => {\n  let value = (max - min) * ratio;\n  if (step > 0) {\n    value = Math.round(value / step) * step + min;\n  }\n  return clamp(min, value, max);\n};\nconst valueToRatio = (value, min, max) => {\n  return clamp(0, (value - min) / (max - min), 1);\n};\nlet rangeIds = 0;\n"],"mappings":"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"}