{"version":3,"names":["contentCss","Content","constructor","hostRef","this","watchDog","isScrolling","lastScroll","queued","cTop","cBottom","isMainContent","resizeTimeout","detail","scrollTop","scrollLeft","type","event","undefined","startX","startY","startTime","currentX","currentY","velocityX","velocityY","deltaX","deltaY","currentTime","data","fullscreen","scrollX","scrollY","scrollEvents","connectedCallback","el","closest","disconnectedCallback","onScrollEnd","onAppLoad","resize","onResize","clearTimeout","setTimeout","offsetParent","shouldForceOverscroll","forceOverscroll","mode","getIonMode","isPlatform","readTask","readDimensions","forceUpdate","page","getPageElement","top","Math","max","offsetTop","bottom","offsetHeight","dirty","onScroll","ev","timeStamp","Date","now","shouldStart","onScrollStart","ts","updateScrollDetail","scrollEl","ionScroll","emit","async","Promise","resolve","componentOnReady","backgroundContentEl","scrollToTop","duration","scrollToPoint","getScrollElement","y","scrollHeight","clientHeight","x","promise","r","fromY","fromX","step","linearTime","min","easedT","pow","floor","requestAnimationFrame","ionScrollStart","clearInterval","setInterval","ionScrollEnd","render","rtl","isRTL","transitionShadow","TagType","h","Host","class","createColorClasses","color","hostContext","overscroll","style","ref","id","part","name","getParentElement","_a","parentElement","parentNode","host","tabs","timestamp","prevX","prevY","prevT","timeDelta"],"sources":["./node_modules/@ionic/core/dist/collection/components/content/content.css?tag=ion-content&encapsulation=shadow","./node_modules/@ionic/core/dist/collection/components/content/content.js"],"sourcesContent":[":host {\n  /**\n   * @prop --background: Background of the content\n   *\n   * @prop --color: Color of the content\n   *\n   * @prop --padding-top: Top padding of the content\n   * @prop --padding-end: Right padding if direction is left-to-right, and left padding if direction is right-to-left of the content\n   * @prop --padding-bottom: Bottom padding of the content\n   * @prop --padding-start: Left padding if direction is left-to-right, and right padding if direction is right-to-left of the content\n   *\n   * @prop --keyboard-offset: Keyboard offset of the content\n   *\n   * @prop --offset-top: Offset top of the content\n   * @prop --offset-bottom: Offset bottom of the content\n   */\n  --background: var(--ion-background-color, #fff);\n  --color: var(--ion-text-color, #000);\n  --padding-top: 0px;\n  --padding-bottom: 0px;\n  --padding-start: 0px;\n  --padding-end: 0px;\n  --keyboard-offset: 0px;\n  --offset-top: 0px;\n  --offset-bottom: 0px;\n  --overflow: auto;\n  display: block;\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: 100%;\n  /* stylelint-disable */\n  margin: 0 !important;\n  padding: 0 !important;\n  /* stylelint-enable */\n  font-family: var(--ion-font-family, inherit);\n  contain: size style;\n}\n\n:host(.ion-color) .inner-scroll {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n:host(.outer-content) {\n  --background: var(--ion-color-step-50, #f2f2f2);\n}\n\n#background-content {\n  left: 0px;\n  right: 0px;\n  top: calc(var(--offset-top) * -1);\n  bottom: calc(var(--offset-bottom) * -1);\n  position: absolute;\n  background: var(--background);\n}\n\n.inner-scroll {\n  left: 0px;\n  right: 0px;\n  top: calc(var(--offset-top) * -1);\n  bottom: calc(var(--offset-bottom) * -1);\n  padding-left: var(--padding-start);\n  padding-right: var(--padding-end);\n  padding-top: calc(var(--padding-top) + var(--offset-top));\n  padding-bottom: calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));\n  position: absolute;\n  color: var(--color);\n  box-sizing: border-box;\n  overflow: hidden;\n  /**\n   * touch-action: manipulation is an alias\n   * for this, but WebKit has an issue\n   * where pointercancel events are not fired\n   * when scrolling: https://bugs.webkit.org/show_bug.cgi?id=240917\n   * Using the long form below avoids the issue.\n   */\n  touch-action: pan-x pan-y pinch-zoom;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .inner-scroll {\n    padding-left: unset;\n    padding-right: unset;\n    -webkit-padding-start: var(--padding-start);\n    padding-inline-start: var(--padding-start);\n    -webkit-padding-end: var(--padding-end);\n    padding-inline-end: var(--padding-end);\n  }\n}\n\n.scroll-y,\n.scroll-x {\n  -webkit-overflow-scrolling: touch;\n  /**\n   * This adds `.inner-scroll` as part of the\n   * stacking context in WebKit. Without it,\n   * children of ion-content are treated as\n   * siblings rather than descendants. This\n   * can result in the children being put\n   * into their own layers, degrading\n   * scrolling performance.\n   *\n   * An optimization called \"layer backing\n   * sharing\" usually kicks in to prevent\n   * this, but having translate3d defeats\n   * this optimization.\n   *\n   * See: https://bugs.webkit.org/show_bug.cgi?id=216701\n   */\n  z-index: 0;\n  will-change: scroll-position;\n}\n\n.scroll-y {\n  overflow-y: var(--overflow);\n  overscroll-behavior-y: contain;\n}\n\n.scroll-x {\n  overflow-x: var(--overflow);\n  overscroll-behavior-x: contain;\n}\n\n.overscroll::before,\n.overscroll::after {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  content: \"\";\n}\n\n.overscroll::before {\n  bottom: -1px;\n}\n\n.overscroll::after {\n  top: -1px;\n}\n\n:host(.content-sizing) {\n  display: flex;\n  flex-direction: column;\n  /**\n   * This resolves a sizing issue in popovers where extra long content\n   * would overflow the popover's height, preventing scrolling. It's a\n   * quirk of flexbox that forces the content to shrink to fit.\n   *\n   * overflow: hidden can't be used here because it prevents the visual\n   * effect from showing on translucent headers.\n   */\n  min-height: 0;\n  contain: none;\n}\n\n:host(.content-sizing) .inner-scroll {\n  position: relative;\n  /**\n   * Because the outer content has display: flex here (to help enable\n   * scrolling in a popover), offsetting via `top` (such as when using\n   * a translucent header) creates white space under the content. Use\n   * a negative margin instead to keep the bottom in place. (A similar\n   * thing happens with `bottom` and footers.)\n   */\n  top: 0;\n  bottom: 0;\n  margin-top: calc(var(--offset-top) * -1);\n  margin-bottom: calc(var(--offset-bottom) * -1);\n}\n\n.transition-effect {\n  display: none;\n  position: absolute;\n  width: 100%;\n  height: 100vh;\n  opacity: 0;\n  pointer-events: none;\n}\n\n:host(.content-ltr) .transition-effect {\n  /* stylelint-disable property-disallowed-list */\n  left: -100%;\n  /* stylelint-enable property-disallowed-list */\n}\n\n:host(.content-rtl) .transition-effect {\n  /* stylelint-disable property-disallowed-list */\n  right: -100%;\n  /* stylelint-enable property-disallowed-list */\n}\n\n.transition-cover {\n  position: absolute;\n  /* stylelint-disable property-disallowed-list */\n  right: 0;\n  /* stylelint-enable property-disallowed-list */\n  width: 100%;\n  height: 100%;\n  background: black;\n  opacity: 0.1;\n}\n\n.transition-shadow {\n  display: block;\n  position: absolute;\n  width: 10px;\n  height: 100%;\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAgCAYAAAAIXrg4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTE3MDgzRkQ5QTkyMTFFOUEwNzQ5MkJFREE1NUY2MjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTE3MDgzRkU5QTkyMTFFOUEwNzQ5MkJFREE1NUY2MjQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxMTcwODNGQjlBOTIxMUU5QTA3NDkyQkVEQTU1RjYyNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxMTcwODNGQzlBOTIxMUU5QTA3NDkyQkVEQTU1RjYyNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PmePEuQAAABNSURBVHjaYvz//z8DIxAwMDAwATGMhmFmPDQuOSZks0AMmoJBaQHjkPfB0Lfg/2gQjVow+HPy/yHvg9GiYjQfjMbBqAWjFgy/4hogwADYqwdzxy5BuwAAAABJRU5ErkJggg==);\n  background-repeat: repeat-y;\n  background-size: 10px 16px;\n}\n\n:host(.content-ltr) .transition-shadow {\n  /* stylelint-disable property-disallowed-list */\n  right: 0;\n  /* stylelint-enable property-disallowed-list */\n}\n\n:host(.content-rtl) .transition-shadow {\n  /* stylelint-disable property-disallowed-list */\n  left: 0;\n  /* stylelint-enable property-disallowed-list */\n  transform: scaleX(-1);\n}\n\n::slotted([slot=fixed]) {\n  position: absolute;\n  /**\n   * When presenting ion-content inside of an ion-modal, the .inner-scroll\n   * element is composited. In WebKit, the fixed content is not composited\n   * causing it to appear under the main scrollable content as a result.\n   * The fixed content is correctly composited in other browsers. Adding\n   * the translateZ forces the fixed content to be composited so it correctly\n   * shows on top of the scrollable content. Setting a negative z-index will\n   * still allow the fixed content to appear under the scroll content if specified.\n   */\n  transform: translateZ(0);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, forceUpdate, h, readTask } from '@stencil/core';\nimport { getIonMode } from '../../global/ionic-global';\nimport { componentOnReady } from '../../utils/helpers';\nimport { isPlatform } from '../../utils/platform';\nimport { isRTL } from '../../utils/rtl';\nimport { createColorClasses, hostContext } from '../../utils/theme';\n/**\n * @slot - Content is placed in the scrollable area if provided without a slot.\n * @slot fixed - Should be used for fixed content that should not scroll.\n *\n * @part background - The background of the content.\n * @part scroll - The scrollable container of the content.\n */\nexport class Content {\n  constructor() {\n    this.watchDog = null;\n    this.isScrolling = false;\n    this.lastScroll = 0;\n    this.queued = false;\n    this.cTop = -1;\n    this.cBottom = -1;\n    this.isMainContent = true;\n    this.resizeTimeout = null;\n    // Detail is used in a hot loop in the scroll event, by allocating it here\n    // V8 will be able to inline any read/write to it since it's a monomorphic class.\n    // https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html\n    this.detail = {\n      scrollTop: 0,\n      scrollLeft: 0,\n      type: 'scroll',\n      event: undefined,\n      startX: 0,\n      startY: 0,\n      startTime: 0,\n      currentX: 0,\n      currentY: 0,\n      velocityX: 0,\n      velocityY: 0,\n      deltaX: 0,\n      deltaY: 0,\n      currentTime: 0,\n      data: undefined,\n      isScrolling: true,\n    };\n    /**\n     * If `true`, the content will scroll behind the headers\n     * and footers. This effect can easily be seen by setting the toolbar\n     * to transparent.\n     */\n    this.fullscreen = false;\n    /**\n     * If you want to enable the content scrolling in the X axis, set this property to `true`.\n     */\n    this.scrollX = false;\n    /**\n     * If you want to disable the content scrolling in the Y axis, set this property to `false`.\n     */\n    this.scrollY = true;\n    /**\n     * Because of performance reasons, ionScroll events are disabled by default, in order to enable them\n     * and start listening from (ionScroll), set this property to `true`.\n     */\n    this.scrollEvents = false;\n  }\n  connectedCallback() {\n    this.isMainContent = this.el.closest('ion-menu, ion-popover, ion-modal') === null;\n  }\n  disconnectedCallback() {\n    this.onScrollEnd();\n  }\n  onAppLoad() {\n    this.resize();\n  }\n  /**\n   * Rotating certain devices can update\n   * the safe area insets. As a result,\n   * the fullscreen feature on ion-content\n   * needs to be recalculated.\n   *\n   * We listen for \"resize\" because we\n   * do not care what the orientation of\n   * the device is. Other APIs\n   * such as ScreenOrientation or\n   * the deviceorientation event must have\n   * permission from the user first whereas\n   * the \"resize\" event does not.\n   *\n   * We also throttle the callback to minimize\n   * thrashing when quickly resizing a window.\n   */\n  onResize() {\n    if (this.resizeTimeout) {\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = null;\n    }\n    this.resizeTimeout = setTimeout(() => {\n      /**\n       * Resize should only happen\n       * if the content is visible.\n       * When the content is hidden\n       * then offsetParent will be null.\n       */\n      if (this.el.offsetParent === null) {\n        return;\n      }\n      this.resize();\n    }, 100);\n  }\n  shouldForceOverscroll() {\n    const { forceOverscroll } = this;\n    const mode = getIonMode(this);\n    return forceOverscroll === undefined ? mode === 'ios' && isPlatform('ios') : forceOverscroll;\n  }\n  resize() {\n    if (this.fullscreen) {\n      readTask(() => this.readDimensions());\n    }\n    else if (this.cTop !== 0 || this.cBottom !== 0) {\n      this.cTop = this.cBottom = 0;\n      forceUpdate(this);\n    }\n  }\n  readDimensions() {\n    const page = getPageElement(this.el);\n    const top = Math.max(this.el.offsetTop, 0);\n    const bottom = Math.max(page.offsetHeight - top - this.el.offsetHeight, 0);\n    const dirty = top !== this.cTop || bottom !== this.cBottom;\n    if (dirty) {\n      this.cTop = top;\n      this.cBottom = bottom;\n      forceUpdate(this);\n    }\n  }\n  onScroll(ev) {\n    const timeStamp = Date.now();\n    const shouldStart = !this.isScrolling;\n    this.lastScroll = timeStamp;\n    if (shouldStart) {\n      this.onScrollStart();\n    }\n    if (!this.queued && this.scrollEvents) {\n      this.queued = true;\n      readTask((ts) => {\n        this.queued = false;\n        this.detail.event = ev;\n        updateScrollDetail(this.detail, this.scrollEl, ts, shouldStart);\n        this.ionScroll.emit(this.detail);\n      });\n    }\n  }\n  /**\n   * Get the element where the actual scrolling takes place.\n   * This element can be used to subscribe to `scroll` events or manually modify\n   * `scrollTop`. However, it's recommended to use the API provided by `ion-content`:\n   *\n   * i.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events\n   * and `scrollToPoint()` to scroll the content into a certain point.\n   */\n  async getScrollElement() {\n    /**\n     * If this gets called in certain early lifecycle hooks (ex: Vue onMounted),\n     * scrollEl won't be defined yet with the custom elements build, so wait for it to load in.\n     */\n    if (!this.scrollEl) {\n      await new Promise((resolve) => componentOnReady(this.el, resolve));\n    }\n    return Promise.resolve(this.scrollEl);\n  }\n  /**\n   * Returns the background content element.\n   * @internal\n   */\n  async getBackgroundElement() {\n    if (!this.backgroundContentEl) {\n      await new Promise((resolve) => componentOnReady(this.el, resolve));\n    }\n    return Promise.resolve(this.backgroundContentEl);\n  }\n  /**\n   * Scroll to the top of the component.\n   *\n   * @param duration The amount of time to take scrolling to the top. Defaults to `0`.\n   */\n  scrollToTop(duration = 0) {\n    return this.scrollToPoint(undefined, 0, duration);\n  }\n  /**\n   * Scroll to the bottom of the component.\n   *\n   * @param duration The amount of time to take scrolling to the bottom. Defaults to `0`.\n   */\n  async scrollToBottom(duration = 0) {\n    const scrollEl = await this.getScrollElement();\n    const y = scrollEl.scrollHeight - scrollEl.clientHeight;\n    return this.scrollToPoint(undefined, y, duration);\n  }\n  /**\n   * Scroll by a specified X/Y distance in the component.\n   *\n   * @param x The amount to scroll by on the horizontal axis.\n   * @param y The amount to scroll by on the vertical axis.\n   * @param duration The amount of time to take scrolling by that amount.\n   */\n  async scrollByPoint(x, y, duration) {\n    const scrollEl = await this.getScrollElement();\n    return this.scrollToPoint(x + scrollEl.scrollLeft, y + scrollEl.scrollTop, duration);\n  }\n  /**\n   * Scroll to a specified X/Y location in the component.\n   *\n   * @param x The point to scroll to on the horizontal axis.\n   * @param y The point to scroll to on the vertical axis.\n   * @param duration The amount of time to take scrolling to that point. Defaults to `0`.\n   */\n  async scrollToPoint(x, y, duration = 0) {\n    const el = await this.getScrollElement();\n    if (duration < 32) {\n      if (y != null) {\n        el.scrollTop = y;\n      }\n      if (x != null) {\n        el.scrollLeft = x;\n      }\n      return;\n    }\n    let resolve;\n    let startTime = 0;\n    const promise = new Promise((r) => (resolve = r));\n    const fromY = el.scrollTop;\n    const fromX = el.scrollLeft;\n    const deltaY = y != null ? y - fromY : 0;\n    const deltaX = x != null ? x - fromX : 0;\n    // scroll loop\n    const step = (timeStamp) => {\n      const linearTime = Math.min(1, (timeStamp - startTime) / duration) - 1;\n      const easedT = Math.pow(linearTime, 3) + 1;\n      if (deltaY !== 0) {\n        el.scrollTop = Math.floor(easedT * deltaY + fromY);\n      }\n      if (deltaX !== 0) {\n        el.scrollLeft = Math.floor(easedT * deltaX + fromX);\n      }\n      if (easedT < 1) {\n        // do not use DomController here\n        // must use nativeRaf in order to fire in the next frame\n        requestAnimationFrame(step);\n      }\n      else {\n        resolve();\n      }\n    };\n    // chill out for a frame first\n    requestAnimationFrame((ts) => {\n      startTime = ts;\n      step(ts);\n    });\n    return promise;\n  }\n  onScrollStart() {\n    this.isScrolling = true;\n    this.ionScrollStart.emit({\n      isScrolling: true,\n    });\n    if (this.watchDog) {\n      clearInterval(this.watchDog);\n    }\n    // watchdog\n    this.watchDog = setInterval(() => {\n      if (this.lastScroll < Date.now() - 120) {\n        this.onScrollEnd();\n      }\n    }, 100);\n  }\n  onScrollEnd() {\n    if (this.watchDog)\n      clearInterval(this.watchDog);\n    this.watchDog = null;\n    if (this.isScrolling) {\n      this.isScrolling = false;\n      this.ionScrollEnd.emit({\n        isScrolling: false,\n      });\n    }\n  }\n  render() {\n    const { isMainContent, scrollX, scrollY, el } = this;\n    const rtl = isRTL(el) ? 'rtl' : 'ltr';\n    const mode = getIonMode(this);\n    const forceOverscroll = this.shouldForceOverscroll();\n    const transitionShadow = mode === 'ios';\n    const TagType = isMainContent ? 'main' : 'div';\n    this.resize();\n    return (h(Host, { class: createColorClasses(this.color, {\n        [mode]: true,\n        'content-sizing': hostContext('ion-popover', this.el),\n        overscroll: forceOverscroll,\n        [`content-${rtl}`]: true,\n      }), style: {\n        '--offset-top': `${this.cTop}px`,\n        '--offset-bottom': `${this.cBottom}px`,\n      } }, h(\"div\", { ref: (el) => (this.backgroundContentEl = el), id: \"background-content\", part: \"background\" }), h(TagType, { class: {\n        'inner-scroll': true,\n        'scroll-x': scrollX,\n        'scroll-y': scrollY,\n        overscroll: (scrollX || scrollY) && forceOverscroll,\n      }, ref: (scrollEl) => (this.scrollEl = scrollEl), onScroll: this.scrollEvents ? (ev) => this.onScroll(ev) : undefined, part: \"scroll\" }, h(\"slot\", null)), transitionShadow ? (h(\"div\", { class: \"transition-effect\" }, h(\"div\", { class: \"transition-cover\" }), h(\"div\", { class: \"transition-shadow\" }))) : null, h(\"slot\", { name: \"fixed\" })));\n  }\n  static get is() { return \"ion-content\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"$\": [\"content.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"$\": [\"content.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"color\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"Color\",\n          \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n          \"references\": {\n            \"Color\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n        },\n        \"attribute\": \"color\",\n        \"reflect\": true\n      },\n      \"fullscreen\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the content will scroll behind the headers\\nand footers. This effect can easily be seen by setting the toolbar\\nto transparent.\"\n        },\n        \"attribute\": \"fullscreen\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"forceOverscroll\": {\n        \"type\": \"boolean\",\n        \"mutable\": true,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true` and the content does not cause an overflow scroll, the scroll interaction will cause a bounce.\\nIf the content exceeds the bounds of ionContent, nothing will change.\\nNote, the does not disable the system bounce on iOS. That is an OS level setting.\"\n        },\n        \"attribute\": \"force-overscroll\",\n        \"reflect\": false\n      },\n      \"scrollX\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If you want to enable the content scrolling in the X axis, set this property to `true`.\"\n        },\n        \"attribute\": \"scroll-x\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"scrollY\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If you want to disable the content scrolling in the Y axis, set this property to `false`.\"\n        },\n        \"attribute\": \"scroll-y\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"scrollEvents\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Because of performance reasons, ionScroll events are disabled by default, in order to enable them\\nand start listening from (ionScroll), set this property to `true`.\"\n        },\n        \"attribute\": \"scroll-events\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      }\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"ionScrollStart\",\n        \"name\": \"ionScrollStart\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the scroll has started. This event is disabled by default.\\nSet `scrollEvents` to `true` to enable.\"\n        },\n        \"complexType\": {\n          \"original\": \"ScrollBaseDetail\",\n          \"resolved\": \"ScrollBaseDetail\",\n          \"references\": {\n            \"ScrollBaseDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionScroll\",\n        \"name\": \"ionScroll\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted while scrolling. This event is disabled by default.\\nSet `scrollEvents` to `true` to enable.\"\n        },\n        \"complexType\": {\n          \"original\": \"ScrollDetail\",\n          \"resolved\": \"ScrollDetail\",\n          \"references\": {\n            \"ScrollDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionScrollEnd\",\n        \"name\": \"ionScrollEnd\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted when the scroll has ended. This event is disabled by default.\\nSet `scrollEvents` to `true` to enable.\"\n        },\n        \"complexType\": {\n          \"original\": \"ScrollBaseDetail\",\n          \"resolved\": \"ScrollBaseDetail\",\n          \"references\": {\n            \"ScrollBaseDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"getScrollElement\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<HTMLElement>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"HTMLElement\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<HTMLElement>\"\n        },\n        \"docs\": {\n          \"text\": \"Get the element where the actual scrolling takes place.\\nThis element can be used to subscribe to `scroll` events or manually modify\\n`scrollTop`. However, it's recommended to use the API provided by `ion-content`:\\n\\ni.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events\\nand `scrollToPoint()` to scroll the content into a certain point.\",\n          \"tags\": []\n        }\n      },\n      \"getBackgroundElement\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<HTMLElement>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"HTMLElement\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<HTMLElement>\"\n        },\n        \"docs\": {\n          \"text\": \"Returns the background content element.\",\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }]\n        }\n      },\n      \"scrollToTop\": {\n        \"complexType\": {\n          \"signature\": \"(duration?: number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"duration The amount of time to take scrolling to the top. Defaults to `0`.\"\n                }],\n              \"text\": \"The amount of time to take scrolling to the top. Defaults to `0`.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Scroll to the top of the component.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"duration The amount of time to take scrolling to the top. Defaults to `0`.\"\n            }]\n        }\n      },\n      \"scrollToBottom\": {\n        \"complexType\": {\n          \"signature\": \"(duration?: number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"duration The amount of time to take scrolling to the bottom. Defaults to `0`.\"\n                }],\n              \"text\": \"The amount of time to take scrolling to the bottom. Defaults to `0`.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Scroll to the bottom of the component.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"duration The amount of time to take scrolling to the bottom. Defaults to `0`.\"\n            }]\n        }\n      },\n      \"scrollByPoint\": {\n        \"complexType\": {\n          \"signature\": \"(x: number, y: number, duration: number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"x The amount to scroll by on the horizontal axis.\"\n                }],\n              \"text\": \"The amount to scroll by on the horizontal axis.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"y The amount to scroll by on the vertical axis.\"\n                }],\n              \"text\": \"The amount to scroll by on the vertical axis.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"duration The amount of time to take scrolling by that amount.\"\n                }],\n              \"text\": \"The amount of time to take scrolling by that amount.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Scroll by a specified X/Y distance in the component.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"x The amount to scroll by on the horizontal axis.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"y The amount to scroll by on the vertical axis.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"duration The amount of time to take scrolling by that amount.\"\n            }]\n        }\n      },\n      \"scrollToPoint\": {\n        \"complexType\": {\n          \"signature\": \"(x: number | undefined | null, y: number | undefined | null, duration?: number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"x The point to scroll to on the horizontal axis.\"\n                }],\n              \"text\": \"The point to scroll to on the horizontal axis.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"y The point to scroll to on the vertical axis.\"\n                }],\n              \"text\": \"The point to scroll to on the vertical axis.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"duration The amount of time to take scrolling to that point. Defaults to `0`.\"\n                }],\n              \"text\": \"The amount of time to take scrolling to that point. Defaults to `0`.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Scroll to a specified X/Y location in the component.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"x The point to scroll to on the horizontal axis.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"y The point to scroll to on the vertical axis.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"duration The amount of time to take scrolling to that point. Defaults to `0`.\"\n            }]\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get listeners() {\n    return [{\n        \"name\": \"appload\",\n        \"method\": \"onAppLoad\",\n        \"target\": \"window\",\n        \"capture\": false,\n        \"passive\": false\n      }, {\n        \"name\": \"resize\",\n        \"method\": \"onResize\",\n        \"target\": \"window\",\n        \"capture\": false,\n        \"passive\": true\n      }];\n  }\n}\nconst getParentElement = (el) => {\n  var _a;\n  if (el.parentElement) {\n    // normal element with a parent element\n    return el.parentElement;\n  }\n  if ((_a = el.parentNode) === null || _a === void 0 ? void 0 : _a.host) {\n    // shadow dom's document fragment\n    return el.parentNode.host;\n  }\n  return null;\n};\nconst getPageElement = (el) => {\n  const tabs = el.closest('ion-tabs');\n  if (tabs) {\n    return tabs;\n  }\n  /**\n   * If we're in a popover, we need to use its wrapper so we can account for space\n   * between the popover and the edges of the screen. But if the popover contains\n   * its own page element, we should use that instead.\n   */\n  const page = el.closest('ion-app, ion-page, .ion-page, page-inner, .popover-content');\n  if (page) {\n    return page;\n  }\n  return getParentElement(el);\n};\n// ******** DOM READ ****************\nconst updateScrollDetail = (detail, el, timestamp, shouldStart) => {\n  const prevX = detail.currentX;\n  const prevY = detail.currentY;\n  const prevT = detail.currentTime;\n  const currentX = el.scrollLeft;\n  const currentY = el.scrollTop;\n  const timeDelta = timestamp - prevT;\n  if (shouldStart) {\n    // remember the start positions\n    detail.startTime = timestamp;\n    detail.startX = currentX;\n    detail.startY = currentY;\n    detail.velocityX = detail.velocityY = 0;\n  }\n  detail.currentTime = timestamp;\n  detail.currentX = detail.scrollLeft = currentX;\n  detail.currentY = detail.scrollTop = currentY;\n  detail.deltaX = currentX - detail.startX;\n  detail.deltaY = currentY - detail.startY;\n  if (timeDelta > 0 && timeDelta < 100) {\n    const velocityX = (currentX - prevX) / timeDelta;\n    const velocityY = (currentY - prevY) / timeDelta;\n    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;\n    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;\n  }\n};\n"],"mappings":"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"}